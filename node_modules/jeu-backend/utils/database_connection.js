const mysql = require("mysql"),
      md5 = require("md5");

class DatabaseConnection {
    constructor() {
        this.db_connection = mysql.createConnection({ // The connection IDs are stored in the VPS's environment variables
            host: process.env.DBHOST,
            user: process.env.DBUSERNAME,
            password: process.env.DBPASSWORD,
            database: process.env.DBNAME
        });
        
        this.db_connection.connect();
        
        
    }
    /*
        getUserData(params: {"username"(string), "password"(string)})
        returns : 
            - Everything OK : user's JSON data
            - New user : user's JSON data + attribute "new_user" set to 1
            - Wrong password : "WRONG_PASSWORD"
    */
    getUserData(params) {
        var result;
        
        params["password"] = md5(params["password"]);
        
        return new Promise((resolve, reject) => {
           this.db_connection.query(`select 
            connexion.username, connexion.password, connexion.id, options.animations, options.volume 
            from options 
            left join connexion 
            on options.joueur_concerne = connexion.id 
            where connexion.username="${params.username}";`, (err, results) => {
               if(err) {                   
                   //console.log(err);
                   reject(err);
               }
               if(results.length === 0) { // If the user has to be created, we call createUser
                   this.createUser(params).then((res) => {
                       if(res.username) { // We check if username exists (the account has been properly created)
                           res.new_user = true; // We tell the client the account has just been created
                           resolve(res);
                       }
                   })
                   
               } else {
                    
                    if(params["password"] == results[0].password) { // If we've got the correct user, we get his options
                        delete results[0].password; // We remove the password before sending back data to the user
                        resolve(results[0]);    
                
                    } else {                    
                        resolve("WRONG_PASSWORD");
                   
                    }    
               }
           }); 
        });        
        
    }

    createUser(userInfo) {

        return new Promise((resolve, reject) => {
           this.db_connection.query(`INSERT INTO connexion VALUES ('', '${userInfo.username}', '${userInfo.password}', '')`, (err, results) => {
               if(err) {

                   if(err.code == "ER_DUP_ENTRY") { // If there is a duplicate entry (the username has already been taken)
                        reject("USERNAME_TAKEN")   
                   } else {
                        reject(err);
                        
                   }
                   
               }
               this.db_connection.query(`SELECT id from connexion where username="${userInfo.username}"`, (err, result) => { // We ask the database the new user's id so that we can store it in sessionStorage, and we get the player's oop
                   userInfo.id = result[0].id;
                   resolve(userInfo);
               }); 
               
               //resolve(userInfo);
           }); 
        });
    }
    
    getUserMatches(user_id) {
        return new Promise((resolve, reject) => {
            this.db_connection.query(`SELECT * FROM matches WHERE ${user_id } in (player1, player2)`, function(err, results) {
                if(err) {
                    reject(err);
                }
                resolve(results);
            }); 
        });  
    }
    
    addMatch(match_info) {
        return new Promise((resolve, reject) => {

           this.db_connection.query(
               `INSERT INTO matches VALUES(
                '', 
                ${match_info["player1"]}, 
                ${match_info["player2"]}, 
                (select id from match_type where match_label="${match_info["type"]}"), 30, ${match_info["winner"]},
                NOW())`,
               (err, results) => {
               
                   if(err) {
                       reject(err);
                
                   } else {
                
                       resolve("SUCCESSFULLY_ADDED");
                   }
               }); 
        });
    }
    
    getUserProfileInfo(id) {
        return new Promise((resolve, reject) => {
            this.db_connection.query(
                `select username, 
                (select count(*) as online_wins from matches where type=2 and ${id} in (player1, player2)) as online_matches,
                (select count(*) from matches where winner=${id} and type=2) as online_wins,
                (select count(*) from matches where type=3 and ${id} in (player1, player2)) as ai_matches,
                (select count(*) from matches where winner=${id} and type=3) as ai_wins
                from connexion where id=${id};`,
                function(err, results) {
                    if(err) {
                        reject(err);
                    } else {

                        resolve(results[0]);
                    }
                })
        });
    }
    
    getOptions(id) {

        return new Promise((resolve, reject) => {

            this.db_connection.query(`SELECT * from options where joueur_concerne=${id};`, function(err, results) {
                
                if(err) {
                    reject(err);
                } else {
                    resolve(results[0]);
                }
            });
        });
    }
    
    setOptions(info) {
        return new Promise((resolve, reject) => {
           this.db_connection.query(`UPDATE options set animations=${info.animations}, volume=${info.volume} where joueur_concerne=${info.joueur_concerne}`, function(err, results) { // Function created for testing purposes only
               if(err) {
                   reject(err);
               } else {
                   resolve(); // Since we update the DB, we don't need to send anything to the function
               }
           }); 
        });
    }
    
    createOptions(id) { // Called after creating a new user (will require a new user to test it because of the foreign key constraint)
        return new Promise((resolve, reject) => {
            this.db_connection.query(`INSERT INTO OPTIONS VALUES ('', ${id}, 1, .5)`, function(err, results) {
                if(err) {
                    reject(err);
                }
                
                resolve();
            });
        });
    }
    
    removeUser(username) { // Utility function, testing purposes only (for now), removes last user
        this.db_connection.query(`DELETE FROM connexion where username='${username}'`);
        this.db_connection.query("ALTER TABLE connexion AUTO_INCREMENT=1"); // We reset the autoincrement to avoid having huge IDs because of tests
    }
    
    removeLastMatch() { // Utility function, testing purposes only (for now)
        this.db_connection.query(`DELETE FROM matches ORDER BY match_id desc limit 1`);
        this.db_connection.query("ALTER TABLE matches AUTO_INCREMENT=1"); // We reset the autoincrement to avoid having huge IDs because of tests
    }
    
    removeLastOptions(username) {
        this.db_connection.query(`DELETE FROM options where joueur_concerne=(select id from connexion where username='${username}')`);
        this.db_connection.query("ALTER TABLE options AUTO_INCREMENT=1"); // We reset the autoincrement to avoid having huge IDs because of tests
    }
}

module.exports = DatabaseConnection;