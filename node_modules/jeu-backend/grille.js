/*jshint esversion:6*/

/*globals $:false */

class Grille {

    constructor(joueur1, joueur2) {

        this.grille = [];
        if(joueur1 && joueur2) {
            this.joueurs = [joueur1, joueur2];    
        }
    
        this.genGrille();
    }

    genGrille() {

        this.genGrilleVide();
        
        // Placement des éléments sur le plateau (cases grisées, joueurs, puis armes, dans cet ordre)
        this.placerCasesGrisees();
        this.placerJoueurs();
        this.placerArmes();
        
    }
    
    /* Fonctions utilitaires génération grille */
    
    genererGrilleVide() {
        
        let x = 0,
            y = 0,
            ligne = [];

        for (y = 0; y < 11; y += 1) {

            ligne = [];

            for (x = 0; x < 11; x += 1) {
                ligne.push("O");
            }

            this.grille.push(ligne);
        }
        
    }
    placerCasesGrisees() {
        let cases_grisees = this.genEmplacementCasesGrisees();

        for (let case_actuelle of cases_grisees) { // On boucle ici pour éviter d'avoir à potentiellement reparcourir tout le tableau à chaque coup
            this.grille[case_actuelle[0]][case_actuelle[1]] = "X";
        }
        
    }
    
    placerJoueurs() {
        let pos_joueurs = this.genPosJoueurs();
        
        for(let nb_joueur = 0; nb_joueur < 2; nb_joueur +=1) {
            let x_joueur = pos_joueurs[nb_joueur][0],
                y_joueur = pos_joueurs[nb_joueur][1];

            this.grille[x_joueur][y_joueur] = String(nb_joueur+1);
        }
    }
    
    placerArmes() {
        let armes = this.genPosArmes();

        for(let nb_arme = 0; nb_arme < 3; nb_arme += 1) {

            let x_arme = armes[nb_arme][0],
                y_arme = armes[nb_arme][1];

            this.grille[x_arme][y_arme] = String.fromCharCode(66+nb_arme); // Renvoie B, C, D

        }
    }
    
    
    /* Autres fonctions */
    getPlayers(joueur1, joueur2) {
        this.joueurs = [joueur1, joueur2];
    }
 
    genEmplacementCasesGrisees() { // Fonction qui génèrera les emplacements des cases grisées (13 pour une grille 11x11)

        let cases_grisees = [],
            verif_elem_array = false;

        for (let nb_case=0; nb_case < 13; nb_case += 1) {

            var coords_gris = this.genXY();
            verif_elem_array = false;

            while(!verif_elem_array) {

                if(!this.elemDansArray(cases_grisees, coords_gris)) {
                        cases_grisees.push(coords_gris);
                        verif_elem_array = true;
                }    

                else {
                    coords_gris = this.genXY();
                }
            }
        }

        return cases_grisees;
    }

    

    genPosJoueurs(){ // Fonction renvoyant la position des joueurs

        var pos_joueurs = [],
            nb_joueur = 0,
            verif_pos_joueur2 = false;

        pos_joueurs.push(this.genXY());

        this.joueurs[0].position = pos_joueurs[0];

        while(!verif_pos_joueur2) { // Si le joueur 2 est sur la même ligne / colonne que le joueur 1, on relancera la génération de position

             var pos_j2 = this.genXY(),
                 pos_j1 = pos_joueurs[0];

            

             if(Math.abs(pos_j2[0] - pos_j1[0]) >= 1 && Math.abs(pos_j2[1] - pos_j1[1]) >= 1) { // pos_j2[0] = x de j2, pos_j2[1] = y de j2

                    pos_joueurs.push(pos_j2);

                    verif_pos_joueur2 = true;   

             } else {

                 pos_j2 = this.genXY();

             }
        }        

        this.joueurs[1].position = pos_joueurs[1];

        return pos_joueurs;

            

    }
        

    genPosArmes() { // Fonction positionnant les armes

        var pos_armes = [],
            nb_arme = 0;

        for(nb_arme; nb_arme < 3; nb_arme += 1) {

            pos_armes.push(this.genXY());

        }

        return pos_armes;
    }

    
    genXY() { // Fonction générant une position [x;y] et vérifiant si elle n'est pas déjà occupée. 

        var random_x = Math.floor((Math.random() * 10)),

            random_y = Math.floor((Math.random() * 10)),

            valid_casevide = false;

        while(!valid_casevide) {

            

            if(this.grille[random_x][random_y] === "O") { // Si l'emplacement n'est pas occupé

                    valid_casevide = true;

                }

                else {

                    random_x = Math.floor(Math.random() * 10);
                    random_y = Math.floor(Math.random() * 10);

                }

        }

        return [random_x, random_y];

    }
    

    verifDeplacementDirection(pos_depart, direction) { // Fonction renvoyant un tableau contenant les déplacements possibles dans une direction donnée (1: haut, 2: gauche, 3: bas, 4: droite)

        var continuer_dep = true,
            cases_dispo = [],
            case_actuelle,
            depart = (direction % 2 === 0) ? pos_depart[0] : pos_depart[1], // Si l'on cherche à voir les déplacements sur [gauche, droite], on met x comme index de référence, sinon y
            axe_inverse = (direction % 2 === 0) ? pos_depart[1] : pos_depart[0],
            actuel = (direction <= 2) ? depart - 1 : depart + 1; // Si l'on veut décrémenter l'index de référence (haut et gauche) ou incrémenter (bas et droite), on cherche la case immédiatement suivante


        while(continuer_dep) {

            if(Math.abs(actuel - depart) === 4 || actuel < 0 || actuel > 10) { // Si l'on arrive aux limites de la carte ou au-delà des restrictions de déplacement, on s'arrête pour cette direction

                continuer_dep = false;

            } else {

                case_actuelle = (direction % 2 === 0) ? this.grille[actuel][axe_inverse] : this.grille[axe_inverse][actuel];

                if(["X", "0", "1"].indexOf(case_actuelle) >= 0 || case_actuelle.length === 2) { // Si la case sur laquelle on se trouve est noircie ou un joueur 

                    continuer_dep = false;

                } else {

                    cases_dispo.push((direction % 2 === 0) ? [actuel, axe_inverse] : [axe_inverse, actuel]); // Même principe que pour l'initialisation de case_actuelle (TODO : améliorer ça)

                }                

            }

            actuel = (direction <= 2) ? actuel - 1 : actuel + 1; // Pour explications, voir initialisation de actuel
        }

        return cases_dispo;

    }
    
    /* 
        Mise à jour de la position du joueur sur la grille back, 
            retour : 
                arme (int, -1 si on n'est pas sur une arme, 
                [-1, id_arme] si le joueur était sur une arme au tour précédent (renvoyé au client pour lui permettre de réafficher l'arme)
                le niveau de l'arme sinon)
        
    */

    updatePosition(joueur, position, nb_tours) { //        

        var pos_actuelle = joueur.position,
            arme = -1;
        
        joueur.position = [parseInt(position[0]), parseInt(position[1])];
        
        if(this.grille[position[0]][position[1]] !== "O") { // Si on est sur une arme, on modifie la variable arme pour permettre au programme de savoir sur laquelle on a cliqué
            console.log("Arme ramassée")
            arme = this.grille[position[0]][position[1]];
            arme = this.transformerValeur(arme);
            this.grille[position[0]][position[1]] = [joueur.id, this.transformerValeur(joueur.arme.id)]; // On stocke un tableau à 2 éléments dans cette case pour pouvoir replacer l'arme au prochain passage
            
            joueur.updateArme(arme, nb_tours);

        } else { // SI on n'est pas sur une arme, on pose uniquement le joueur sur sa nouvelle case
            this.grille[position[0]][position[1]] = String(joueur.id); // On affiche la trace du joueur sur sa nouvelle
        }

    
        if(this.grille[pos_actuelle[0]][pos_actuelle[1]] instanceof Array) { // Si le joueur avait ramassé une arme au tour précédent : (qu'on avait stocké l'id du joueur + celui de l'arme sur une case)
            let ancienne_arme = this.grille[pos_actuelle[0]][pos_actuelle[1]][1];

            this.grille[pos_actuelle[0]][pos_actuelle[1]] = ancienne_arme; // Remet la case en place
            arme = [this.transformerValeur(ancienne_arme)];
        } else {
                
            this.grille[pos_actuelle[0]][pos_actuelle[1]] = "O"; // On efface la trace du joueur sur son ancienne position

        }
        console.log(`On renvoie ${arme}`);
    
        return arme;
    }

    calculDepDispos(position) { // Renvoie un tableau contenant les déplacements possibles du joueur

        var cases_dispo = [],
            cases_courantes, // Récupèrera les cases dispo de verifDeplacementDirection, sera itéré avec case_courante
            case_courante,
            direction = 1; // Utilisé dans le foreach pour ajouter à cases_dispo 


        for(direction; direction < 5; direction += 1) { // On vérifie les direction de 1 (haut) à 4 (gauche) (cf verifDeplacementDirection)

            cases_courantes = this.verifDeplacementDirection(position, direction);

            for(case_courante of cases_courantes) {

                cases_dispo.push(case_courante);

            }

        }

        return cases_dispo;

    }

    /* 
    
        FONCTIONS UTILITAIRES 
    */

    elemDansArray(array, element) { // Workaround de indexOf dans un tableau 2d

        for(let index_element = 0; index_element < array.length; index_element += 1) {
            
            var array_element = array[index_element];

            if(array_element[0] == element[0] && array_element[1] == element[1]) {
                return true;
            }

        }

        return false;

    }

    transformerValeur(val) { // Fonction transformant un caractère en nombre ou inversement

        if(typeof(val) === "string") {
            return val.charCodeAt(0) - 64;
        } else {
            return String.fromCharCode(val + 64);
        }
    }

    estEnCombat() {

        var pos_j1 = this.joueurs[0].position,
            pos_j2 = this.joueurs[1].position;

        return Math.abs(pos_j1[0] - pos_j2[0]) === 0 &&  Math.abs(pos_j1[1] - pos_j2[1]) === 1 || Math.abs(pos_j1[0] - pos_j2[0]) === 1 &&  Math.abs(pos_j1[1] - pos_j2[1]) === 0; 
    }
}

module.exports = Grille;